// Copyright August 2020 Maxset Worldwide Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package handlers

import (
	"net/http"
	"strconv"
	"strings"

	"git.maxset.io/web/knaxim/internal/database"
	"git.maxset.io/web/knaxim/internal/database/types"
	"git.maxset.io/web/knaxim/internal/database/types/tag"
	"git.maxset.io/web/knaxim/pkg/srverror"
	"git.maxset.io/web/knaxim/pkg/srvjson"
	"github.com/gorilla/mux"
)

//AttachNLP adds route to router for getting nlp data generated by the processing system
func AttachNLP(r *mux.Router) {
	r.Use(ConnectDatabase)
	r.Use(ParseBody)
	r.Use(UserCookie)
	r.Use(srvjson.JSONResponse)
	r.HandleFunc("/file/{fid}/{synth}/{start}/{end}", sendNLP).Methods("GET")
}

func sendNLP(out http.ResponseWriter, r *http.Request) {
	w := out.(*srvjson.ResponseWriter)

	vals := mux.Vars(r)
	start, err := strconv.Atoi(vals["start"])
	if err != nil {
		panic(srverror.New(err, 400, "Bad Request, expected to provide range as numbers"))
	}
	end, err := strconv.Atoi(vals["end"])
	if err != nil {
		panic(srverror.New(err, 400, "Bad Request, expected to provide range as numbers"))
	}
	if start >= end {
		panic(srverror.Basic(400, "Bad Request, initial index must be less then final index"))
	}
	if end > 50 {
		panic(srverror.Basic(400, "Bad Request, final index too large"))
	}
	var tagtype tag.Type
	switch strings.ToLower(vals["synth"]) {
	case "t":
		fallthrough
	case "topic":
		tagtype = tag.TOPIC
	case "a":
		fallthrough
	case "action":
		tagtype = tag.ACTION
	case "r":
		fallthrough
	case "resource":
		tagtype = tag.RESOURCE
	case "p":
		fallthrough
	case "process":
		tagtype = tag.PROCESS
	default:
		panic(srverror.Basic(400, "Bad Request, unrecognized nlp category"))
	}
	fid, err := types.DecodeFileID(vals["fid"])
	if err != nil {
		panic(srverror.New(err, 400, "Bad Request, Bad file id"))
	}
	fb := r.Context().Value(types.FILE).(database.Filebase)
	file, err := fb.Get(fid)
	if err != nil {
		panic(err)
	}
	user := r.Context().Value(USER).(types.Owner)
	if !file.CheckPerm(user, "view") && !file.GetOwner().Match(user) {
		panic(srverror.Basic(403, "Access Denied"))
	}
	sb := r.Context().Value(types.STORE).(database.Storebase)
	fs, err := sb.Get(fid.StoreID)
	if err != nil {
		panic(err)
	}
	if fs.Perr != nil {
		panic(srverror.Basic(fs.Perr.Status, fs.Perr.Message))
	}
	tb := r.Context().Value(types.TAG).(database.Tagbase)
	tags, err := tb.GetType(fid, user.GetID(), tagtype)
	if err != nil {
		panic(err)
	}
	if len(tags) < end {
		end = len(tags)
		if start >= end {
			return
		}
	}
	result := make([]struct {
		Word  string `json:"word"`
		Count int    `json:"count"`
	}, end-start)
	for _, t := range tags {
		var position int
		switch v := t.Data[tagtype]["significance"].(type) {
		case int:
			position = v
		case int32:
			position = int(v)
		case int64:
			position = int(v)
		}
		if position >= start && position < end {
			result[position-start].Word = t.Word
			switch v := t.Data[tagtype]["count"].(type) {
			case int:
				result[position-start].Count = v
			case int32:
				result[position-start].Count = int(v)
			case int64:
				result[position-start].Count = int(v)
			}
		}
	}
	w.Set("fid", fid)
	w.Set("info", result)
}
